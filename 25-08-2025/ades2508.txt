Parte 1: Entendendo como as funÃ§Ãµes funcionam na memÃ³ria
QUESTÃƒO 1 â€” Explorando a passagem de parÃ¢metros por valor
InstruÃ§Ãµes:
1. Clique aqui para verificar um programa com a funÃ§Ã£o ğ‘–ğ‘šğ‘ğ‘Ÿğ‘–ğ‘šğ‘’() no Python Tutor. Vai abrir uma pÃ¡gina como
a da Figura 1.
2. Execute o programa passo a passo e responda Ã s questÃµes abaixo. Use os botÃµes â€œNextâ€ e â€œPrevâ€ para
avanÃ§ar e voltar na execuÃ§Ã£o.

Agora, reflita e responda:
a) As variÃ¡veis ğ‘ e ğ‘ da funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›() realmente receberam os valores 3 e 4?
Resposta:
Sim, elas receberam os valores 3 e 4. Tanto as variÃ¡veis a e b da funÃ§Ã£o main() quanto as variÃ¡veis a e b da funÃ§Ã£o imprime. 	

b) Compare os endereÃ§os de memÃ³ria de ğ‘ e ğ‘ dentro da funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›() com os endereÃ§os de ğ‘ e ğ‘ dentro 
da funÃ§Ã£o ğ‘–ğ‘šğ‘ğ‘Ÿğ‘–ğ‘šğ‘’().
â†’ O que vocÃª observa? Eles sÃ£o os mesmos? Por quÃª?
Resposta:
NÃ£o, os endereÃ§os de memÃ³ria de a e b dentro da funÃ§Ã£o main() e a e b dentro da funÃ§Ã£o imprime sÃ£o distintos. Em cada funÃ§Ã£o
os endereÃ§os de memÃ³ria das variÃ¡veis assumem valores diferentes. Isso ocorre porquÃª as funÃ§Ãµes sÃ£o independentes, cada funÃ§Ã£o 
tem seu escopo e seu espaÃ§o de memÃ³ria local para as suas variÃ¡veis. Trata-se da passagem por valor.

c) Com base nisso, explique com suas palavras:
â†’ O que significa dizer que os valores foram copiados para a funÃ§Ã£o ğ‘–ğ‘šğ‘ğ‘Ÿğ‘–ğ‘šğ‘’()?
Respostas:
Dizer que os valores foram copiados significa dizer que os valores foram copiados e atribuÃ­dos Ã  outras variÃ¡veis na funÃ§Ã£o imprime().
Os valores do main() foram armazenados e copiados para variÃ¡veis especÃ­ficas da funÃ§Ã£o imprime(). O que Ã© quase equivalente a copiar a 
variÃ¡vel, com a diferenÃ§a de que se tratam de variÃ¡veis distintas e diferentes, com endereÃ§os diferentes, porÃ©m, ambas com um mesmo valor 
atribuÃ­do.Ã‰ a passagem por valor.

Dica:Mesmo que os nomes das variÃ¡veis sejam os mesmos (a e b), nÃ£o sÃ£o as mesmas variÃ¡veis na memÃ³ria.
Elas estÃ£o em Ã¡reas diferentes, e o conteÃºdo Ã© apenas copiado para a funÃ§Ã£o. Isso Ã© o que chamamos de passagem
por valor.


Sobre a funÃ§Ã£o imprime:
Neste programa, usamos uma funÃ§Ã£o chamada ğ‘–ğ‘šğ‘ğ‘Ÿğ‘–ğ‘šğ‘’(), que tem o tipo ğ‘£ğ‘œğ‘–ğ‘‘.
Isso significa que a funÃ§Ã£o nÃ£o retorna nenhum valor para quem a chamou.
Ela simplesmente executa uma aÃ§Ã£o (neste caso, imprime na tela os valores de ğ‘ e ğ‘) e termina ali.
FunÃ§Ãµes ğ‘£ğ‘œğ‘–ğ‘‘ sÃ£o Ãºteis quando queremos apenas exibir algo, modificar variÃ¡veis por referÃªncia ou registrar
alguma informaÃ§Ã£o, sem a necessidade de retorno

QUESTÃƒO 2 â€” Outro exemplo de passagem de parÃ¢metro por valor
InstruÃ§Ãµes:
1. Clique aqui para verificar um programa com a funÃ§Ã£o ğ‘šğ‘’ğ‘‘ğ‘–ğ‘() no Python Tutor. Vai abrir uma pÃ¡gina como a
da Figura 2 a seguir.
2. Execute o programa passo a passo usando os botÃµes â€œNextâ€ e â€œPrevâ€.
3. Observe com atenÃ§Ã£o o comportamento das variÃ¡veis e os valores retornados.
Agora, reflita e responda:
a) Em qual linha a funÃ§Ã£o ğ‘šğ‘’ğ‘‘ğ‘–ğ‘() foi chamada? Quais valores foram copiados para os parÃ¢metros ğ‘ e ğ‘ da
funÃ§Ã£o ğ‘šğ‘’ğ‘‘ğ‘–ğ‘()?
Resposta:
A funÃ§Ã£o media() foi chamada na linha de nÃºmero 16 e ainda teve seu valor atribuÃ­do a uma variÃ¡vel "m".	

b) Compare os endereÃ§os de memÃ³ria de ğ‘ e ğ‘ dentro da funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›() com os endereÃ§os de ğ‘ e ğ‘ dentro
da funÃ§Ã£o ğ‘šğ‘’ğ‘‘ğ‘–ğ‘().
â†’ O que vocÃª observa? Eles sÃ£o os mesmos? Por quÃª?
Resposta:
Os endereÃ§os de memÃ³ria de a e b dentro da funÃ§Ã£o main() e a e b na funÃ§Ã£o media() sÃ£o distintas, assim
como na questÃ£o 1.

c) Qual valor foi retornado pela funÃ§Ã£o ğ‘šğ‘’ğ‘‘ğ‘–ğ‘()?
â†’ Quem recebeu esse valor na funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›()?
Resposta:
O valor obtido como mÃ©dia foi o valor de 3,5. A variÃ¡vel "m" da main() que recebeu o valor da mÃ©dia, 3.5.

d) Vamos aprender a editar o programa!
â€¢ Clique em â€œğ‘¬ğ’…ğ’Šğ’• ğ’•ğ’‰ğ’Šğ’” ğ’„ğ’ğ’…ğ’†â€ no Python Tutor.
â€¢ Agora, modifique a linha onde a mÃ©dia Ã© calculada: em vez de (ğ‘ + ğ‘) / 2.0, coloque apenas (ğ‘ + ğ‘) / 2.
â†’ O que aconteceu com o resultado? Por quÃª?
Resposta:
O resultado deixou de ser 3.5 e passou a ser somente 3, perdeu a parte decimal. Isto ocorre porque a divisÃ£o
passou a ser uma divisÃ£o inteira, com resultado inteiro, diferentemente de uma divisÃ£o real, com um resultado
real. O resultado deixou de ser 3.5 e passou a ser 3. 

Dica: Quando usamos apenas / 2, estamos fazendo uma divisÃ£o inteira, e o resultado pode ser truncado. Usar
2.0 forÃ§a uma divisÃ£o real (com casas decimais).

QUESTÃƒO 3 â€” Explorando a passagem de parÃ¢metros por referÃªncia
InstruÃ§Ãµes:
1. Clique aqui para verificar um programa com a funÃ§Ã£o ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() no Python Tutor. Vai abrir uma pÃ¡gina como a
da Figura 3 a seguir.
2. Execute o programa passo a passo usando os botÃµes â€œNextâ€ e â€œPrevâ€.
3. Observe com atenÃ§Ã£o o comportamento das variÃ¡veis, os valores trocados e os endereÃ§os de memÃ³ria
Agora, reflita e responda:
a) O que aconteceu quando a funÃ§Ã£o ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() foi chamada?
Resposta:
A funÃ§Ã£o troca(), ao ser chamada, usou a variÃ¡vel auxiliar "aux" para armazenar o valor de x e
atribuiu o valor de y para x. Desta forma, ambas ficaram com o valor de x. Por fim, a funÃ§Ã£o pegou
o valor de x, armazenado na variÃ¡vel auxiliar "aux" e atribuiu a y. Desta forma, as variÃ¡veis "trocaram"
de posiÃ§Ã£o, x passando a ter o valor de y e y passando a a ter o valor de x.
 
â†’ As variÃ¡veis ğ‘¥ e ğ‘¦ estÃ£o referenciando diretamente as variÃ¡veis ğ‘ e ğ‘ da funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›().
â†’ Quando ğ‘ğ‘¢ğ‘¥ recebe o valor de ğ‘¥, ele estÃ¡, na prÃ¡tica, armazenando o valor de ğ‘.
â†’ Quando ğ‘¥ recebe ğ‘¦, Ã© como se a estivesse recebendo o valor de ğ‘.
 Tudo isso acontece porque os parÃ¢metros estÃ£o sendo passados por referÃªncia (&), ou seja, nÃ£o hÃ¡
cÃ³pia dos valores â€” a funÃ§Ã£o acessa diretamente as variÃ¡veis originais.
b) VocÃª percebeu que os valores de ğ‘¥ e ğ‘¦ estÃ£o, na verdade, ligados aos endereÃ§os de memÃ³ria de ğ‘ e ğ‘?
Resposta:
Sim.

â†’ Isso demonstra que ğ‘¥ e ğ‘¦ nÃ£o sÃ£o cÃ³pias, mas sim referÃªncias para os mesmos espaÃ§os de memÃ³ria
onde estÃ£o ğ‘ e ğ‘.
c) Agora edite a funÃ§Ã£o ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() removendo os sÃ­mbolos & dos parÃ¢metros.
â†’ Execute novamente no Python Tutor.
â†’ O que vocÃª observa?
Resposta:
Eu observo que ocorreu que os valores nÃ£o foram invertidos. Permaneceram na ordem original.

 Os valores de ğ‘ e ğ‘ nÃ£o sÃ£o mais trocados, porque agora os parÃ¢metros sÃ£o passados por valor, e a funÃ§Ã£o
estÃ¡ trabalhando apenas com cÃ³pias.
 Dica: A passagem por referÃªncia permite que uma funÃ§Ã£o modifique diretamente as variÃ¡veis que estÃ£o
fora dela. Ã‰ ideal quando vocÃª precisa alterar valores sem retornar nada!

QUESTÃƒO 4 â€” Mais um exemplo de passagem de parÃ¢metros por referÃªncia
InstruÃ§Ãµes:
1. Clique aqui para verificar um programa com as funÃ§Ãµes ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘() e ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() no Python Tutor. Vai abrir uma
pÃ¡gina como a da Figura 4 a seguir.
2. Execute o programa passo a passo usando os botÃµes â€œNextâ€ e â€œPrevâ€.
3. Observe com atenÃ§Ã£o o comportamento das variÃ¡veis, os valores trocados e os endereÃ§os de memÃ³ria.
Agora, reflita e responda:
â€¢ Quantas funÃ§Ãµes estÃ£o definidas no programa? (Lembre-se: a funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›() tambÃ©m Ã© uma funÃ§Ã£o.)
Resposta:
No programa hÃ¡ 3 funÃ§Ãµes definidas: 
*"void troca(int &x, int &y)"
*"void ordena(int &x, int &y,int &z)"
*"int main()"

â€¢ Qual funÃ§Ã£o chama outra funÃ§Ã£o?
Resposta:
*A funÃ§Ã£o "void ordena(int &x, int &y, int &z)" chama a funÃ§Ã£o "void troca(int &x, int &y)" 3 vezes.
*A funÃ§Ã£o "int main()" chama a funÃ§Ã£o "void ordena(int &x, int &y, int &z)".

â€¢ Que tipo de parÃ¢metros as funÃ§Ãµes ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘() e ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() utilizam: valor ou referÃªncia?
Resposta:
A funÃ§Ã£o "ordena()" e a funÃ§Ã£o "troca()" utilizam o parÃ¢metro por referÃªncia.

â€¢ Observe os valores trocados dentro da funÃ§Ã£o ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘(). Ela modifica os valores originais? Por quÃª?
Resposta:
Sim, a funÃ§Ã£o ordena modifica os valores originais pois esta funÃ§Ã£o faz a passagem por referÃªncia, o que
modifica os valores originais.

â€¢ Qual Ã© o papel da funÃ§Ã£o ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() dentro da funÃ§Ã£o ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘()?
Resposta:
A funÃ§Ã£o troca() serve para fazer a mudanÃ§a de posiÃ§Ã£o de x,y e z conforme for o resultado obtido pela checagem
que Ã© feita pela funÃ§Ã£o "ordena()", pela estrutura condicional, de ifs.

â€¢ Se as funÃ§Ãµes ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘() e ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘() fossem escritas com passagem por valor, o programa ainda funcionaria
corretamente? Explique por que nÃ£o seria possÃ­vel manter a mesma lÃ³gica.
Resposta:
NÃ£o, nÃ£o seria possÃ­vel manter esta lÃ³gica pois, sem a passagem de valor, passando somente por valor, nÃ£o passando o "endereÃ§o" da variÃ¡vel e alterando a variÃ¡vel original, a funÃ§Ã£o void ordena() e void troca() perderiam todo o seu sentido, pois nÃ£o alterariam nada na funÃ§Ã£o int main(). A ordem de nada seria alterada no main, a funÃ§Ã£o troca n
trocaria a ordem.

 Desafio opcional â€” Reescrevendo sem funÃ§Ãµes auxiliares
â€¢ Reescreva o programa colocando toda a lÃ³gica de ordenaÃ§Ã£o diretamente dentro da funÃ§Ã£o ğ‘šğ‘ğ‘–ğ‘›() (ou seja,
sem criar as funÃ§Ãµes ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘›ğ‘() e ğ‘¡ğ‘Ÿğ‘œğ‘ğ‘()).
 ReflexÃ£o:
â€¢ O cÃ³digo ficou mais claro ou mais confuso?
Resposta:
Mais confuso.

â€¢ Ficou mais fÃ¡cil ou mais difÃ­cil de manter?
Resposta:
DifÃ­cil.

â€¢ Agora vocÃª entende por que usamos funÃ§Ãµes?
Resposta:
Sim.

 Dica: FunÃ§Ãµes que utilizam parÃ¢metros por referÃªncia sÃ£o muito Ãºteis em algoritmos de ordenaÃ§Ã£o porque
permitem alterar diretamente os valores originais. Isso torna o cÃ³digo mais limpo e eficiente em situaÃ§Ãµes
em que a modificaÃ§Ã£o direta dos dados Ã© desejada.

QUESTÃƒO 5 â€” Misturando passagem por valor e por referÃªncia
InstruÃ§Ãµes:
â€¢ Clique aqui para verificar um programa com a funÃ§Ã£o ğ‘ ğ‘’ğ‘ğ‘ğ‘Ÿğ‘ğ‘ƒğ‘ğ‘Ÿğ‘¡ğ‘’ğ¼ğ‘›ğ‘¡ğ‘’ğ‘–ğ‘Ÿğ‘ğ·ğ‘’ğ‘ğ‘–ğ‘šğ‘ğ‘™() no Python Tutor. Vai
abrir uma pÃ¡gina como a da Figura 5 a seguir.
â€¢ Execute o programa passo a passo usando os botÃµes â€œNextâ€ e â€œPrevâ€.
â€¢ Observe como o uso combinado de passagem por valor e por referÃªncia afeta as variÃ¡veis.
Agora, reflita e responda:
a) Qual foi o valor final exibido para ğ‘£ğ‘ğ‘™ğ‘œğ‘Ÿ, ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘–ğ‘Ÿğ‘ e ğ‘‘ğ‘’ğ‘ğ‘–ğ‘šğ‘ğ‘™?
Resposta:
Os valores finais foram:
valor =12.75;
inteira=12;
decimal =0.75;

b) A funÃ§Ã£o ğ‘ ğ‘’ğ‘ğ‘ğ‘Ÿğ‘ğ‘ƒğ‘ğ‘Ÿğ‘¡ğ‘’ğ¼ğ‘›ğ‘¡ğ‘’ğ‘–ğ‘Ÿğ‘ğ·ğ‘’ğ‘ğ‘–ğ‘šğ‘ğ‘™() modificou o valor da variÃ¡vel valor?
â†’ Por que isso nÃ£o aconteceu?
Resposta:
NÃ£o. Isto nÃ£o aconteceu porque a funÃ§Ã£o separaParteInteiraDecimal() faz a passagem de parÃ¢metros,
de tal modo em que nÃ£o se altera o valor da variÃ¡vel valor.

c) E quanto Ã s variÃ¡veis ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘–ğ‘Ÿğ‘ e ğ‘‘ğ‘’ğ‘ğ‘–ğ‘šğ‘ğ‘™? Por que elas foram modificadas corretamente?
Resposta:
Isto ocorre porque na funÃ§Ã£o void separaParteDecimal(float numero, int &parteInteira, float &parteDecimal),
os parÃ¢metros parteInteira (inteira) e parteDecimal (decimal) foram passadas por referÃªncia, de tal forma
em que elas foram modificadas corretamente.
 

d) O que esse exemplo demonstra sobre a diferenÃ§a entre passagem por valor e passagem por referÃªncia
quando usadas juntas na mesma funÃ§Ã£o?
Resposta:
Demonstra e deixa mais clara a diferenÃ§a entre os dois tipos de passagem. O parÃ¢metro que foi passado por valor nÃ£o teve modificaÃ§Ãµes em main(). JÃ¡, em contraponto, os dois parÃ¢metros passados por referÃªncia explicitaram a modificaÃ§Ã£o que ocorreu em main().

e) VocÃª sabia que uma funÃ§Ã£o sÃ³ pode retornar um valor por vez usando ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›? Neste exemplo, usamos
passagem por referÃªncia como estratÃ©gia para "retornar" mais de um resultado. VocÃª consegue imaginar
outras situaÃ§Ãµes em que isso seria Ãºtil?
Resposta:
NÃ£o. Em qualquer situaÃ§Ã£o em que seja interessante mais de um resultado ser retornado por uma funÃ§Ã£o especÃ­fica 

 Dica: Quando usamos passagem por valor, as alteraÃ§Ãµes ocorrem em uma cÃ³pia. JÃ¡ na passagem por
referÃªncia, a variÃ¡vel original Ã© diretamente modificada. Essa tÃ©cnica tambÃ©m pode ser usada quando queremos que
uma funÃ§Ã£o forneÃ§a mais de um resultado.
AlÃ©m disso, Ã© importante lembrar que quando o comando ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘› Ã© executado, a funÃ§Ã£o termina imediatamente â€” por
isso, sÃ³ Ã© possÃ­vel retornar um Ãºnico valor diretamente por ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›. Se quisermos "retornar" mais de um valor,
usamos variÃ¡veis por referÃªncia. Quando usamos passagem por valor, as alteraÃ§Ãµes ocorrem em uma cÃ³pia. JÃ¡ na
passagem por referÃªncia, a variÃ¡vel original Ã© diretamente modificada. VocÃª pode usar os dois tipos na mesma
funÃ§Ã£o, dependendo do que deseja alterar ou preservar.
